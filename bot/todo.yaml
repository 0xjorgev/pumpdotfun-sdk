# TODO
- TODO: fees. Send instruction request in base64 to avoid "otros" to see our fees

- EC2:
  √ Deploy app in
    √√ Mini and check if it works
    # - Small and check if it works
  - Have a permanent IP address

- New endopints
  - Post: get burn and close quote
    √ Create openAPI specs
    √ Create pydantic classes
    √ Create enpoint /associated_token_accounts/burn_and_close/transaction
      √ Will call burn_and_close_associated_token_account without keypair
      √ Will return a Transaction.new_unsigned (create the Message) 
        √ encode in base64 and return
    - WIll include 5% fees as a new instruction
      - Check lookuptables
      √ Create new function get_current_ghostfunds_fees(ata_to_be_closed: int)->float
      √ Return the fees in the count endpoint
      √ Get the fee as a new input variable in:
        /associated_token_accounts/burn_and_close/instructions
      √ Create a new function get_fee_instructions(fees: float)->[Instruction]
        √ Business logic will be defined here
        √ Phase1: All 5% will go to Ghost account
        - Phase2: When we have a token. We'll sent some % to another Ghost account to finally buy our own tokens.


- BUG: when a timeout occurs during subscription, the next step is
       BUY and should be unsubscribe to token.

- BUG: When token is too old, It should  hear again from redisdb
       Now is continuing the steps.



- Fees service:
  - Create a service that will subscribe to
  sniper pubkey and get any changes in its state
  and log it in redis.
    - Create a new index for this

- Scanner: 
  * will delete all tokens -> is_checked == False
  -> Work with black list and discard any token made by blacked developers

- Docker: run automatically
- Bash: apply command arguments to choose
  how to run the celebrimborg: Sniper, messaging
  - Send messsages when things goes wrong

- Replace prints with Logging with timestamp